## Introduction

---

Les interfaces d'objets permettent de créer du code qui spécifie quelles méthodes une classe doit implémenter, sans avoir à définir comment ces méthodes sont implémentées.

Les interfaces sont définies de la même façon qu'une classe, mais en utilisant le mot-clé `interface` à la place de `class`, et sans qu'aucune des méthodes n'ait son contenu spécifié.

Une interface est un contrat qui définit un ensemble de méthodes publiques qu'une classe doit implémenter. Contrairement aux classes abstraites, les interfaces ne peuvent pas contenir de logique d'implémentation, elles servent uniquement à définir la structure que les classes doivent suivre.

Les interfaces peuvent être étendues comme des classes, en utilisant l'opérateur `extends`. Une interface peut étendre une ou plusieurs autres interfaces, héritant ainsi de leurs méthodes.

### Interface vs Classe abstraite

---

Une interface est comme un protocole ou un accord. Lorsqu'une classe dit "j'implémente l'interface Y", elle promet d'avoir les mêmes méthodes publiques que tout objet implémentant cette interface.

L'interface définit comment votre code communique avec n'importe quel objet l'implémentant.

Une classe abstraite est comme une classe partiellement construite, un document avec des espaces à remplir. Lorsqu'une classe dit "j'étends la classe abstraite Y", elle utilise des méthodes ou propriétés déjà définies dans cette autre classe.

En résumé : utilisez une interface pour définir un contrat de méthodes publiques, utilisez une classe abstraite pour partager du code réutilisable entre classes liées.

### Exemples

---

```php
<?php
interface Logger {
    public function log(string $message): void;
}

class FileLogger implements Logger {
    public function log(string $message): void {
        file_put_contents('app.log', $message . PHP_EOL, FILE_APPEND);
    }
}

$logger = new FileLogger();
$logger->log("This is a log message.");
```

```php
<?php
interface Shape {
    public function area(): float;
    public function perimeter(): float;
}

class Circle implements Shape {
    private float $radius;

    public function __construct(float $radius) {
        $this->radius = $radius;
    }

    public function area(): float {
        return pi() * ($this->radius ** 2);
    }

    public function perimeter(): float {
        return 2 * pi() * $this->radius;
    }
}

$circle = new Circle(5);
echo "Area: " . $circle->area(); // Area: 78.539816339745
echo "Perimeter: " . $circle->perimeter(); // Perimeter: 31.415926535898
```

## Constantes et propriétés

---

### Propriétés

---

À partir de PHP 8.4, les interfaces peuvent également déclarer des propriétés. Si c'est le cas, la déclaration doit spécifier si la propriété est lisibile, modifiable ou les deux.

```php
<?php
interface User {
    public string $name;
    public readonly int $id;
}

class Member implements User {
    public string $name;
    public readonly int $id;

    public function __construct(string $name, int $id) {
        $this->name = $name;
        $this->id = $id;
    }
}

$member = new Member("Alice", 1);
echo $member->name; // Alice
echo $member->id;   // 1
```

### Constantes

---

Les interfaces peuvent contenir des constantes. Les constantes d'interfaces fonctionnent exactement comme les constantes de classe.

```php
<?php
interface Status {
    public const ACTIVE = 'active';
    public const INACTIVE = 'inactive';
}

echo Status::ACTIVE; // active
```
