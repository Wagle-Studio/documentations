## D√©clarer une classe

---

Une d√©finition de classe basique commence par le mot-cl√© `class`, suivi du nom de la classe. Une paire d'accolades contient ensuite la d√©finition des propri√©t√©s et des m√©thodes appartenant √† la classe.

Le nom de la classe peut √™tre quelconque, √† condition qu'il ne soit pas un mot r√©serv√© en PHP.

üîó [Mots r√©serv√©s en PHP](https://www.php.net/manual/fr/reserved.php)

Lorsque l'on √©voque les classes en programmation orient√©e objet, il est important d'utiliser le bon vocabulaire :

- Les variables de classe sont appel√©es "propri√©t√©s" ou "attributs"

- Les fonctions de classe sont appel√©es "m√©thodes"

- Les constantes de classe restent appel√©es "constantes"

```php
<?php

class MyClass {
    public $message = 'Hello world';

    public function readMessage() {
        echo $this->message;
    }
}
```

### La pseudo-variable `$this`

---

La pseudo-variable `$this` repr√©sente une r√©f√©rence √† l'instance courante de la classe.

Elle est disponible uniquement √† l'int√©rieur des m√©thodes non-statiques d'une classe. `$this` permet d'acc√©der aux propri√©t√©s et m√©thodes de l'objet depuis l'int√©rieur de la classe.

Par exemple, dans le code ci-dessus, `$this->message` permet d'acc√©der √† la propri√©t√© `message` de l'instance courante.

Important : La pseudo-variable `$this` n'est pas disponible dans les contextes suivants :

- Dans les m√©thodes d√©clar√©es comme `static`

- Dans les fonctions en dehors d'une classe

- Dans les closures (fonctions anonymes) sauf si elles sont li√©es √† un objet

Pour acc√©der aux membres statiques d'une classe, utilisez plut√¥t l'op√©rateur de r√©solution de port√©e `::` avec le nom de la classe.

## Instancier une classe

---

Pour cr√©er une instance d'une classe, on utilise le mot‚Äëcl√© `new`. Un objet est alors cr√©√© et, si d√©fini, le constructeur de la classe est ex√©cut√©.

L'utilisation de `new` avec une expression (par exemple une variable contenant le nom d'une classe) est support√©e. Cela permet diff√©rentes approches pour l'instanciation, notamment l'instanciation dynamique.

```php
<?php

class MyClass {
    public $message = 'Hello world';

    public function readMessage() {
        echo $this->message;
    }
}

$instance = new MyClass();

$className = 'MyClass';

$otherInstance = new $className();
```

## Propri√©t√©s, constantes et m√©thodes

---

Les propri√©t√©s et m√©thodes de classe r√©sident dans des "espaces de noms" s√©par√©s. Il est donc possible d'avoir une propri√©t√© et une m√©thode portant le m√™me nom dans une classe.

L'acc√®s √† une propri√©t√© ou l'appel d'une m√©thode d√©pend uniquement de la syntaxe utilis√©e :

- `$instance->demo` acc√®de √† la propri√©t√©

- `$instance->demo()` appelle la m√©thode

```php
<?php

class MyClass {
    public $demo = 'Hello world';      // Propri√©t√©

    public function demo() {           // M√©thode
        echo "Goodbye world";
    }
}

$instance = new MyClass();

echo $instance->demo;    // Affiche : Hello world
$instance->demo();       // Affiche : Goodbye world
```

### Les propri√©t√©s

---

Une propri√©t√© est d√©finie en utilisant au moins un modificateur d'acc√®s. Les modificateurs disponibles sont :

- `public` : accessible de partout

- `protected` : accessible dans la classe et ses classes enfants

- `private` : accessible uniquement dans la classe

- `static` : appartient √† la classe et non √† l'instance

- `readonly` : (PHP 8.1+) propri√©t√© modifiable uniquement une fois

Les propri√©t√©s peuvent √™tre typ√©es (recommand√©) :

```php
class Product {
    public string $name;                    // Propri√©t√© typ√©e simple
    private static int $count = 0;          // Propri√©t√© statique avec valeur initiale
    public readonly float $price;           // Propri√©t√© en lecture seule (typage obligatoire)
    protected ?string $description = null;  // Propri√©t√© nullable
}
```

√Ä savoir :

- Propri√©t√©s d'instance : `$this->propertyName`

- Propri√©t√©s statiques : `self::$propertyName` ou `NomDeLaClasse::$propertyName`

- Les propri√©t√©s `readonly` n√©cessitent un type explicite

- Par d√©faut, PHP autorise l'ajout de propri√©t√©s dynamiques

### Propri√©t√©s contenant des fonctions

---

Il est possible de stocker une fonction anonyme (closure) dans une propri√©t√©. Pour l'ex√©cuter, la syntaxe n√©cessite des parenth√®ses suppl√©mentaires :

```php
<?php

class MyClass {
    public $demo;

    public function __construct() {
        $this->demo = function() {
            return 'Hello world';
        };
    }
}

$instance = new MyClass();

// Les parenth√®ses autour de $instance->demo sont n√©cessaires
// pour indiquer que nous voulons ex√©cuter la fonction stock√©e
echo ($instance->demo)(); // Affiche : Hello world
```

### Les constantes

---

Dans une classe il est possible de d√©finir des constantes qui restent identiques et non modifiables. La visibilit√© par d√©faut de constantes de classe est public.

Il est aussi possible pour les interfaces d'avoir des constantes.

√Ä partir de PHP 8.3, les constantes de classe peuvent avoir un type scalaire tel que bool, int, float, string, ou m√™me array. Lorsqu‚Äôon utilise array, son contenu ne peut contenir que d'autres types scalaires.

```php
<?php

class MyClass {
    const CONSTANT = "valeur constante"

    public function showConstant() {
        echo self::CONSTANT;
    }
}

$instance = new MyClass();

$instance->showConstant(); // Affiche : valeur constante
```

√Ä savoir :

- La constante sp√©ciale ::class permet une r√©solution de nom de classe pleinement qualifi√© au moment de la compilation, cela est utile pour les classes dans un espace de nom

## Assignation d'un objet

---

Il est important de distinguer l'affectation (assignation) et la r√©f√©rence en PHP, surtout pour les objets.

Depuis PHP 5, les objets sont g√©r√©s via un gestionnaire d'objet (un "handle"). L'affectation d'une instance √† une variable copie ce handle, pas l'objet lui‚Äëm√™me. Autrement dit, deux variables peuvent pointer vers le m√™me objet en m√©moire sans pour autant √™tre des alias l'une de l'autre.

```php
$instance = new SimpleClass();

$assigned = $instance;       // copie du handle : nouvelle variable pointant vers le m√™me objet
$reference =& $instance;     // alias de la variable $instance

$instance->var = 'valeur A';
$instance = null; // r√©affectation de la variable $instance

var_dump($instance);  // NULL
var_dump($reference); // NULL (car $reference est un alias de $instance)
var_dump($assigned);  // object(SimpleClass) ‚Äî l'objet est toujours accessible via $assigned
```

### Assignation classique

---

```php
$assigned = $instance;
```

Cette affectation copie simplement le handle (pointeur) de `$instance` vers `$assigned`, pas l'objet lui‚Äëm√™me. Les deux variables pointent donc vers le m√™me objet, mais elles sont ind√©pendantes au niveau des variables elles‚Äëm√™mes :

- Modifier une propri√©t√© de l'objet via `$instance` sera visible via `$assigned`

- R√©affecter `$instance` (par exemple `$instance = null`) ne modifie pas `$assigned` : l'objet reste accessible via `$assigned`

### Assignation par r√©f√©rence

---

```php
$reference =& $instance;
```

Cette d√©claration fait de `$reference` un alias de `$instance`.

Les deux variables sont li√©es directement, elles d√©signent la m√™me variable, pas seulement le m√™me objet. Elles ne sont pas ind√©pendantes, toute modification de la variable (pas seulement de l'objet) se r√©percute sur l'autre.

Si l'on r√©affecte `$instance = null`, cela sera aussi le cas pour `$reference`

## Classes en lecture seule (readonly)

---

Depuis PHP 8.2, une classe peut √™tre marqu√©e avec le modificateur `readonly`. Cette fonctionnalit√© permet de garantir l'immutabilit√© des objets apr√®s leur initialisation.

Une classe marqu√©e `readonly` a les caract√©ristiques suivantes :

- Toutes ses propri√©t√©s sont automatiquement `readonly`

- La cr√©ation de propri√©t√©s dynamiques est interdite

- Les propri√©t√©s doivent √™tre typ√©es explicitement

- Les propri√©t√©s ne peuvent √™tre modifi√©es qu'une seule fois, dans le constructeur

- Une classe `readonly` ne peut √™tre √©tendue que par une autre classe `readonly`

- Les propri√©t√©s statiques ne peuvent pas √™tre `readonly`

```php
<?php

readonly class User {
    public function __construct(
        public string $name,
        public string $email
    ) {}
}

$user = new User('John Doe', 'john@example.com');
echo $user->name; // Affiche : John Doe

// Erreur : Cannot modify readonly property User::$name
$user->name = 'Jane Doe';

// Erreur : Cannot create dynamic property User::$age
$user->age = 25;
```
