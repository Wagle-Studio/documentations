## Introduction

---

Il existe plusieurs façons de restreindre l’accès à un site distribué par Apache. La méthode la plus simple consiste à utiliser un fichier `.htpasswd`.

Une fois en place, l’accès au site nécessite la saisie d’identifiants valides. Cette solution est adaptée à une instance de préproduction ou à un site interne.

## Mise en place du fichier .htpasswd

---

Mettre en place cette restriction consiste à stocker une combinaison identifiant + mot de passe dans un fichier `.htpasswd`, situé dans le dossier `/etc/apache2`.

Générez le fichier et un premier utilisateur avec la commande suivante :

```bash
# à compléter
sudo htpasswd -c /etc/apache2/.<nom_du_htpasswd> <mon_utilisateur>

# exemple
sudo htpasswd -c /etc/apache2/.my_project kevin
```

Pour ajouter un nouvel utilisateur sans recréer le fichier :

```bash
sudo htpasswd /etc/apache2/.<nom_du_htpasswd_existant> <autre_utilisateur>
```

Si vous préférez organiser plusieurs fichiers de mots de passe, créez un dossier et placez-y vos fichiers :

```bash
sudo mkdir -p /etc/apache2/sites-htpasswd # vous êtes libre de nommer ce dossier

# à compléter : création d'un htpasswd dans un dossier personnalisé
sudo htpasswd -c /etc/apache2/<votre_dossier>/.<nom_du_htpasswd> <mon_utilisateur>

# exemple
sudo htpasswd -c /etc/apache2/sites-htpasswd/.my_project kevin
```

## Configuration du virtual host

---

Ajoutez les directives d’authentification dans le virtual host, dans un bloc `<Directory>` ou `<Location>` selon le périmètre à protéger.

N'oubliez pas de retirer `Require all granted`, qui entrerait en conflit avec `Require valid-user`.

### Exemple avec site statique

---

```txt
<VirtualHost *:80>
    ServerName my-static-site.fr
    ServerAlias www.my-static-site.fr

    DocumentRoot /var/www/my_static_site

    <Directory /var/www/my_static_site>
        Options Indexes FollowSymLinks
        AllowOverride All

        AuthType Basic
        AuthName "Restricted access"
        AuthUserFile /etc/apache2/sites-htpasswd/.my_static_site
        Require valid-user
    </Directory>

    ErrorLog ${APACHE_LOG_DIR}/my_static_site_error.log
    CustomLog ${APACHE_LOG_DIR}/my_static_site_access.log combined
</VirtualHost>
```

Ce bloc protège l’ensemble du site statique. Dès que l’utilisateur tente d’y accéder, une fenêtre d’authentification s’affiche.

### Exemple avec reverse proxy

---

```txt
<VirtualHost *:80>
    ServerName my-app-dev.fr
    ServerAlias www.my-app-dev.fr

    ProxyPreserveHost On

    <Location />
        AuthType Basic
        AuthName "Restricted access"
        AuthUserFile /etc/apache2/sites-htpasswd/.my_app
        Require valid-user
    </Location>

    ProxyPass        / http://localhost:4174/ retry=0
    ProxyPassReverse / http://localhost:4174/

    ProxyPass        /_next/webpack-hmr ws://localhost:4174/_next/webpack-hmr
    ProxyPassReverse /_next/webpack-hmr ws://localhost:4174/_next/webpack-hmr

    RequestHeader set X-Forwarded-Proto "http"
    RequestHeader set X-Forwarded-Port "80"

    ErrorLog ${APACHE_LOG_DIR}/my_app_error.log
    CustomLog ${APACHE_LOG_DIR}/my_app_access.log combined
</VirtualHost>
```

Ici, la restriction est appliquée au niveau du `<Location />`, ce qui bloque tout accès au proxy tant que l’utilisateur n’a pas fourni d’identifiants valides.

Cette configuration est idéale pour protéger une application Node.js ou autre application dynamique derrière Apache.

### Exemple mixte (public et proxy protégé)

---

```txt
<VirtualHost *:80>
    ServerName my-project-dev.fr

    DocumentRoot /var/www/my_project

    <Directory /var/www/my_project/public>
        Options Indexes FollowSymLinks
        AllowOverride All
        Require all granted
    </Directory>

    <Location />
        AuthType Basic
        AuthName "Restricted area"
        AuthUserFile /etc/apache2/sites-htpasswd/.my_project
        Require valid-user
    </Location>

    ProxyPreserveHost On

    ProxyPass        /public !
    ProxyPass        / http://localhost:4174/ retry=0
    ProxyPassReverse / http://localhost:4174/

    ProxyPass        /_next/webpack-hmr ws://localhost:4174/_next/webpack-hmr
    ProxyPassReverse /_next/webpack-hmr ws://localhost:4174/_next/webpack-hmr

    ErrorLog ${APACHE_LOG_DIR}/my_project_error.log
    CustomLog ${APACHE_LOG_DIR}/my_project_access.log combined
</VirtualHost>
```

Dans cet exemple, seul le dossier `/public` reste libre d’accès. Tout le reste du site passe par le proxy et nécessite une authentification.

### Vérification et redémarrage

---

```bash
sudo apache2ctl configtest
sudo systemctl restart apache2
```

Dès lors, le site ou l’application n’est plus accessible sans identifiants.

## .htpasswd et protocole HTTPS

---

Si vous avez des configurations distinctes pour HTTP et HTTPS (un fichier de configuration écoutant sur le port 80 pour HTTP et un autre écoutant sur le port 443 pour HTTPS), assurez-vous d’implémenter la demande d’authentification uniquement dans la configuration HTTPS.

Le fichier de configuration HTTP sert uniquement à rediriger automatiquement les utilisateurs vers HTTPS. Il n’est donc pas nécessaire de le sécuriser par un mot de passe, puisqu'il n’est pas accessible directement. Vous devez restreindre l’accès seulement sur la version HTTPS.

## Gestion de plusieurs .htpasswd

---

Le nom du fichier `.htpasswd` importe peu. Ce qui compte est le chemin vers ce fichier, déclaré dans `AuthUserFile` du virtual host.

Vous êtes libre d’organiser et de créer vos fichiers `.htpasswd` comme vous le souhaitez.

L’essentiel est de déclarer le chemin vers le fichier désiré dans les virtual hosts appropriés.

```bash
etc/
├─ apache2/
│  ├─ sites-available/
│  │  ├─ my_project.conf
│  │  ├─ my_other_project.conf
│  │
│  ├─ sites-enabled/
│  │
│  ├─ sites-htpasswd/
│  │  ├─ .my_project
│  │  ├─ .my_other_project
```
