## Introduction

---

Le Dockerfile est un script interprÃ©tÃ© par Docker. Vous devez y dÃ©finir les commandes nÃ©cessaires pour configurer lâ€™environnement fourni par lâ€™image de base.

Lâ€™objectif de ce fichier est de construire une image Docker spÃ©cifique, contenant tout ce dont votre application a besoin pour fonctionner.

Une fois cette image crÃ©Ã©e, elle servira de modÃ¨le pour dÃ©marrer un ou plusieurs conteneurs capables dâ€™exÃ©cuter votre application dans un environnement isolÃ©, reproductible et maÃ®trisÃ©.

## Contenu du Dockerfile

---

Le fichier `Dockerfile` se trouve gÃ©nÃ©ralement Ã  la racine de votre projet.

Le document suivant illustrera la construction dâ€™un Dockerfile pour une application Next.js.

### L'image de base

---

En premier lieu, il est nÃ©cessaire de spÃ©cifier lâ€™environnement que vous souhaitez utiliser comme base.Lâ€™image de base dÃ©finit cet environnement, incluant les dÃ©pendances et les composants nÃ©cessaires Ã  son fonctionnement.

Lâ€™installation de ces composants est dÃ©jÃ  prise en charge par lâ€™image de base, vous nâ€™avez donc rien Ã  faire de ce cÃ´tÃ©.

> ğŸ’¡ Bon Ã  savoir : une image Docker est composÃ©e d'une succession de couches empilÃ©es les unes sur les autres. Chaque couche reprÃ©sente une Ã©tape de construction, depuis le systÃ¨me dâ€™exploitation de base jusquâ€™Ã  la configuration dâ€™un environnement complet ou personnalisÃ©.

Ces images sont disponibles sur ğŸ”— [Docker Hub](https://hub.docker.com/), un registre oÃ¹ vous pouvez rechercher et tÃ©lÃ©charger des images adaptÃ©es Ã  vos besoins.

Une application Next.js nÃ©cessite un environnement Node.js. Lâ€™image de base devra donc Ãªtre une image de Node.js.

```yml
FROM node:24-alpine3.21
```

Bien que vous puissiez crÃ©er un conteneur directement Ã  partir de cette image, celui-ci serait vide et inutilisable sans y ajouter vos fichiers et configurations.

### Dossier de travail

---

Dans un premier temps, vous devez dÃ©finir un dossier de travail dans le conteneur, câ€™est-Ã -dire lâ€™emplacement oÃ¹ toutes les commandes suivantes seront exÃ©cutÃ©es par dÃ©faut.

Cette commande crÃ©er un dossier `app` et le dÃ©fini comme rÃ©pertoire de travail.

```yml
WORKDIR /app
```

### Installer les dÃ©pendances

---

Cette partie dÃ©pend de la nature de votre projet. Ici, nous continuerons avec lâ€™exemple dâ€™un Dockerfile pour une application Next.js.

Lâ€™exÃ©cution de lâ€™application Next.js nÃ©cessite lâ€™installation des dÃ©pendances listÃ©es dans les fichiers `package.json` et `package-lock.json`.

Pour que ces dÃ©pendances soient installÃ©es dans le conteneur, vous devez copier ces deux fichiers, puis lancer lâ€™installation des dÃ©pendances.

La commande suivante crÃ©e une copie des fichiers `package*.json` dans le dossier racine du conteneur (le dossier `app` crÃ©Ã© prÃ©cÃ©demment), puis installe les dÃ©pendances :

```yml
COPY package*.json ./

RUN npm install
```

Ensuite, vous devez copier lâ€™ensemble du projet dans le conteneur afin dâ€™y inclure le code source, les ressources et la structure complÃ¨te de votre application.

Cette sÃ©paration en deux Ã©tapes (copie des fichiers `package*.json` puis du reste du projet) permet Ã  Docker de mettre en cache lâ€™installation des dÃ©pendances.

Ainsi, si seules les sources de votre projet changent, Docker rÃ©utilise les couches prÃ©cÃ©demment construites sans rÃ©installer les dÃ©pendances, ce qui accÃ©lÃ¨re considÃ©rablement les reconstructions.

```yml
COPY . .
```

**RÃ©capitulatif des actions listÃ©es dans le Dockerfile :**

1. Utiliser lâ€™image Node comme base pour l'environnement.

2. CrÃ©er un dossier `app` dans le conteneur et lâ€™utiliser comme dossier racine.

3. Copier les fichiers `package.json` et `package-lock.json` dans le conteneur.

4. ExÃ©cuter lâ€™installation des dÃ©pendances.

5. Copier le reste du projet dans le conteneur.

### Exposer lâ€™application

---

Le ou les ports utilisÃ©s varient selon la nature de votre application (par exemple, Next.js utilise le port 3000). Par dÃ©faut, aucun port nâ€™est exposÃ© en dehors du conteneur, ce qui rend lâ€™application inaccessible depuis lâ€™extÃ©rieur.

Pour rendre votre application accessible, vous devez mapper le port interne du conteneur (ici le port 3000) Ã  un port de votre machine hÃ´te. Cela nÃ©cessite dâ€™indiquer le port Ã  exposer directement dans le script Dockerfile.

La commande suivante expose le port 3000 du conteneur afin quâ€™il puisse Ãªtre associÃ© Ã  celui de votre machine, permettant ainsi dâ€™accÃ©der Ã  lâ€™application exÃ©cutÃ©e dans le conteneur :

```yml
EXPOSE 3000
```

Il ne reste plus quâ€™une Ã©tape pour que tout fonctionne : dÃ©finir la commande de dÃ©marrage du projet.

Cette commande indique Ã  Docker quelle instruction exÃ©cuter lorsque le conteneur dÃ©marre, une fois que toutes les Ã©tapes du script ont Ã©tÃ© terminÃ©es.

```yml
CMD ["npm", "run", "dev"]
```

### Exemple complet

---

```yml
FROM node:24-alpine3.21

WORKDIR /app

COPY package*.json ./

RUN npm install

COPY . .

EXPOSE 3000

CMD ["npm", "run", "dev"]
```

## Exploiter l'image

---

Une fois votre Dockerfile prÃªt, vous pouvez crÃ©er une image Ã  partir de celui-ci.

Placez-vous dans le terminal Ã  la racine de votre projet, lÃ  oÃ¹ se trouve le fichier Dockerfile, puis exÃ©cutez la commande suivante :

```bash
docker build -t <nom_pour_votre_image> .
```

Cette commande demande Ã  Docker de lire le Dockerfile, dâ€™exÃ©cuter chaque instruction et de construire une image complÃ¨te, prÃªte Ã  Ãªtre utilisÃ©e.

Une fois lâ€™image construite, vous pouvez dÃ©marrer un conteneur basÃ© sur celle-ci avec la commande suivante :

```bash
docker run -p 3000:3000 <nom_de_votre_image_cree_precedemment>
```

Lâ€™option `-p 3000:3000` mappe le port 3000 du conteneur (celui exposÃ© dans le Dockerfile) au port 3000 de votre machine, ce qui permet dâ€™y accÃ©der depuis votre navigateur.

Votre application Next.js est dÃ©sormais en cours dâ€™exÃ©cution et accessible.

